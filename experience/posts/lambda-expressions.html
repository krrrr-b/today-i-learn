<!DOCTYPE html>
<html lang="kr">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="krr-b 기술블로그">
  <meta name="author" content="krr-b">
  <title>민웅이서점</title>

  <link href="../vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  <link href="../css/one-page-wonder.min.css" rel="stylesheet">
  <link rel="stylesheet" type="text/css" crossorigin="anonymous" href="http://meta-kage.kakaocdn.net/dn/osa/blog/assets/fonts/Kakao.css"/>
  <link rel="stylesheet" type="text/css" crossorigin="anonymous" href="http://meta-kage.kakaocdn.net/dn/osa/blog/assets/fonts/SpoqaHanSans.css"/>

  <style>
    a {
      color: #000;
      text-decoration: none !important;
    }

    a:hover {
      color: #5F00FF;
    }

    .container {
      font-family: 'Spoqa Han Sans' !important, sans-serif;
      font-weight: lighter;
    }

    h2.display-5 {
      font-family: 'Kakao' !important, sans-serif;
      font-weight: lighter;
    }

    .kakao {
      font-family: 'Kakao' !important, sans-serif;
      font-weight: lighter;
    }

    .spoqa {
      font-family: 'Spoqa Han Sans' !important, sans-serif; 
      font-weight: lighter !important;
    }

    .spoqa-bold {
      font-family: 'Spoqa Han Sans' !important, sans-serif; 
      font-weight: bold !important;
    }

  </style>
</head>

<body style="width: 1076px !important; margin-right: 15% !important; margin-left: 15% !important;">

  <nav class="navbar navbar-expand-lg navbar-dark navbar-custom fixed-top" style="margin-right: 15% !important; margin-left: 15% !important; width: 1076px !important">
    <div class="container">
      <a class="navbar-brand spoqa" href="https://krr-b.github.io">민웅이서점</a>
    </div>
  </nav>

  <header class="masthead text-center text-white" style="background-image: url(../notebook.jpg);">
    <div class="masthead-content">
      <div class="container">
        <h1 class="masthead-heading mb-0 spoqa">Lambda Expressions</h1>
      </div>
    </div>
  </header>

  <section>
    <div class="container" style="margin-top: 50px; margin-bottom: 300px;">
람다 표현식(Lambda Expressions)이란 간단히 말해 메소드를 하나의 식으로 표현하는 것이다.<br/><br/>
            <pre style="font-family: 'Kakao'; font-weight: lighter; font-size: 12pt; background-color: #5D5D5D; color: #FFF;">

        /*
         * AS-IS
         */
        <b style="color: #6799FF;">int min(int x, int y) {
          return x < y ? x : y;
        }</b>

        /*
         * TO-BE
         */
        <b style="color: #6799FF;">(x, y) -> x < y ? x : y;</b>
    </pre><br/>
      위의 예제처럼 메소드를 람다 표현식으로 표현하면, 클래스를 작성하고 객체를 생성하지 않아도 메소드를 사용할 수 있습니다.<br/>
<br/>
      그런데 자바에서는 클래스의 선언과 동시에 객체를 생성하므로, 단 하나의 객체만을 생성할 수 있는 클래스를 익명 클래스라고 합니다.<br/>
      따라서 <b style="color: #5F00FF;">자바에서 람다 표현식은 익명 클래스와 같다</b>고 할 수 있다.<br/>
<br/>
      이러한 람다 표현식은 메소드의 매개변수로 전달될 수도 있으며, 메소드의 결과 값으로 반환될 수도 있습니다.<br/>
      따라서 <b style="color: #5F00FF;">람다 표현식을 사용하면 기존의 불필요한 코드를 줄여주고, 작성된 코드의 가독성을 높여줍니다.</b><br/>
<br/>
      자바에서는 화살표(->) 기호를 사용하여 람다 표현식을 작성할 수 있습니다.<br/>
      <b style="color: #5F00FF;">(매개변수목록) -> {함수몸체}</b><br/>
<br/>
      자바에서 람다 표현식을 작성할 때 유의해야 할 사항은 다음과 같습니다.<br/><br/>

      1. 매개변수의 타입을 추론할 수 있는 경우에는 타입을 생략할 수 있습니다.<br/>
      2. 매개변수가 하나인 경우에는 괄호(())를 생략할 수 있습니다.<br/>
      3. 함수의 몸체가 하나의 명령문만으로 이루어진 경우에는 중괄호({})를 생략할 수 있습니다. (이때 세미콜론(;)은 붙이지 않음)<br/>
      4. 함수의 몸체가 하나의 return 문으로만 이루어진 경우에는 중괄호({})를 생략할 수 없습니다.<br/>
      5. return 문 대신 표현식을 사용할 수 있으며, 이때 반환값은 표현식의 결과 값이 됩니다. (이때 세미콜론(;)은 붙이지 않음)<br/><br/>

      <pre style="font-family: 'Kakao'; font-weight: lighter; font-size: 12pt; background-color: #5D5D5D; color: #FFF;">

        /*
         * AS-IS
         */
        <b style="color: #6799FF;">new Thread(new Runnable() {
            public void run() {
                System.out.println("전통적인 방식의 일회용 스레드 생성");
            }
        }).start();</b>

        /*
         * TO-BE
         */
        <b style="color: #6799FF;">new Thread(()->{ System.out.println("람다 표현식을 사용한 일회용 스레드 생성"); }).start();</b>
    </pre><br/>
      <h4>함수형 인터페이스</h4>
        람다 표현식을 사용할 때는 람다 표현식을 저장하기 위한 참조 변수의 타입을 결정해야만 합니다.<br/>
        아래는 기본적으로 JDK에서 기본적으로 지원하는(built-in) 람다 인터페이스 리스트이다. <br/><br/>
        <pre style="font-family: 'Kakao'; font-weight: lighter; font-size: 12pt; background-color: #5D5D5D; color: #FFF;">
       
            @FunctionalInterface
            public interface Predicate<T> {
                boolean test(T t);
            }

            임의의 타입 T 형태의 객체입력을 받아 그 값이 true인지 false 인지를 리턴한다.

            @FunctionalInterface
            public interface Function<T, R> {
                R apply(T t);
            }

            첫번째 임의의 형태의 입력값을 받아  두번째 임의의 형태의 값으로 출력한다. 
            출력값의 형태를 자유 자재로 지정할수 있기 때문에, 상속을 통해 굉장히 다양하게 사용될수 있는 람다 인터페이스이다.

            @FunctionalInterface
            public interface Consumer<T> {
                void accept(T t);
            }

            임의형태의 입력값을 받고, 출력은 하지 않는 형태의 인터페이스이다. 대표적으로 사용되는 곳은 Collections.sort명령의 인자값이다.

            @FunctionalInterface
            public interface Supplier<T> {
                T get();
            }

            입력값은 따로 없지만, 출력값의 형태를 지정할수 있다.
        </pre>
            <h4>확장형 람다 인터페이스</h4>
            <xmp style="font-family: 'Kakao'; font-weight: lighter; font-size: 12pt; background-color: #5D5D5D; color: #FFF;">
        java.util.function.BiConsumer<T,U>
        : 임의형태의 입력값<T>와 <U> 을 받고, 출력은 하지 않는 형태의 인터페이스이다.

        예)
        BiConsumer<String, String> biConsumer = (x, y) ->  System.out.println(x+","+y);
        biConsumer.accept("First", "Second");

        결과) 
        First,Second


        java.util.function.DoubleFunction
        : java.util.function.Function<T,R> 에서 확장한 람다식으로서,입력과 출력모두 double형태로 받는 람다식
     
        예)
        DoubleFunction doubleFunc = (a)-> a*0.1;
        System.out.println("DoubleFunction test for a ="+ doubleFunc.apply(10));

        결과) 
        DoubleFunction test for a =1.0


        java.util.function.LongToDoubleFunction
        : java.util.function.Function<T,R> 에서 확장한 람다식으로서,입력은 long로 받고 출력은 double형태로 리턴하는 람다식

        예)
        LongToDoubleFunction lToDLambda = a-> a;
        System.out.println("LongToDoubleFunction test for a ="+ lToDLambda.applyAsDouble(10));

        결과) 
        LongToDoubleFunction test for a =10.0


        java.util.function.ObjIntConsumer 
        : 첫번째 파라미터는 객체(Object),두번째 파라미터는 int형을 받는 람다식의 선언

        예)
        java.util.function.ObjIntConsumer oIConsumer = (a,b) -> {System.out.println("Object a="+a+" b="+b);};
        oIConsumer.accept("TestString", 100);

        결과)
        Object a=TestString b=100


        java.util.function.ToDoubleBiFunction<T,U>
        : 첫번째 파라미터는 <T>형태, 두번째 파라미터는 <U>형태를 받아, 결과값으로는 double형태의 값을 리턴하는 람다식

        예)
        ToDoubleBiFunction<String,String> tdbLambda = (a,b)->a.length()+b.length();
        System.out.println("ToDoubleBiFunction test ="+ tdbLambda.applyAsDouble("abc", "def"));

        결과) 
        ToDoubleBiFunction test =6.0


        java.util.function.BinaryOperator<T>
        : 같은 <T>형태의 두개의 파라미터를 받아서 람다식의 계산식대로 계산하고, 계산후의 결과값또한 <T>형태로 리턴하는 람다식
      
        예)
        BinaryOperator<String> binOp=(a,b)->a+","+b; 
        System.out.println("BinaryOperator test for a and b="+ binOp.apply("Hello","World"));

        결과) 
        BinaryOperator test for a and b=Hello,World

        java.util.function.UnaryOperator<T>
        : java.util.function.Function<T,R> 에서 확장한 람다식으로서, <T>형태의 입력값을 받아 <T>형태의 출력값을 리턴한다.

        예)
        java.util.function.UnaryOperator<String> uo = (x)->x.toUpperCase();
        System.out.println("UnaryOperator test ="+ uo.apply("hello"));

        결과) 
        UnaryOperator test = HELLO
        </xmp><br/>
        각 인터페이스의 목표에 맞게 사용하는 것이 좋다.<br/>
<br/>
        1) bi~ 로 시작하는 두개의 각기 다른 형태의 파라미터를 위한 람다패턴(예-BiConsumer)<br/>
        2) Double 혹은 Integer등의 primitive 형태의 입력과 리턴을 을 처리하기 위한 람다패턴 (예 - DoubleFunction)<br/>
        3) 각기 다른 형태의 입출력 형태를 처리하기 위한 람다패턴 (예 - LongToDoubleFunction)<br/>
        4) 두개의 각기 다른 형태의 입력 형태를 처리하기 위한 람다패턴 (예 - ObjIntConsumer)<br/>
        5) 두개의 각기 다른 형태의 입력 형태를 처리해서, 특정형태로 리턴하기 위한 람다패턴 (예 - ToDoubleBiFunction)<br/>
        6) 두개의 같은 형태의 입력을 처리해서, 입력형태와 같은 형태로 출력하기 위한 람다패턴 (예 - BinaryOperator)<br/>
        7) 한개의 입력형태를 처리해서, 입력형태와 같은 형태로 출력하기 위한 람다패턴 (예 - UnaryOperator)<br/>
    <xmp style="font-family: 'Kakao'; font-weight: lighter; font-size: 12pt; background-color: #5D5D5D; color: #FFF;">
    /*
     * forEach
     *
     * 기존의 List, Map, Set등에서 forEach API가 람다를 파라미터값으로 받는다.
     * 람다식 안에서는 각 엘리먼트에 대한 개별 처리를 정의한다.
     * 이러한 람다식의 엘리먼트 처리방식은 기존이 iteration 방식에 비해 다음과 같은 차이가 있다.
     */
    private void forEach()
    {
        List<Object> objects = new ArrayList<>();

        /*
         * AS-IS
         */
        for (Object e : objects) {

        }

        /*
         * TO-BE
         */
        objects.forEach(e -> {

        });
    }

    private void list() {
        List<String> list = new ArrayList<>();

        list.add("A");
        list.add("B");

        /*
         * TO-BE
         */
        list.forEach((x) -> System.out.println("List item =" + x));
    }

    private void map() {
        Map<Integer, String> map = new HashMap<>();

        map.put(1, "first");
        map.put(2, "second");

        /*
         * TO-BE
         */
        map.forEach((x, y) -> System.out.println("Map item x=" + x + " y=" + y));
    }

    private void set() {
        Set<String> set = new HashSet();

        set.add("set1");
        set.add("set2");

        /*
         * TO-BE
         */
        set.forEach(x -> System.out.println("Set item x=" + x));
    }

    /*
     * Stream
     *
     * Stream 객체는 배열혹은 컬렉션 객체에 들어있는 데이터를 이용해 다양한 질의 처리를 하기 위한 객체이다.
     * 컬렉션이나 배열을 사용해서 질의 처리를 하려면 각각의 배열요소에 대해 외부 반복(iteration)을 해줘야 하고,
     * 반복문에 여러 로직을 넣는 중첩구조를 가져가거나 이를 위한 별로의 함수를 만들어야 하는데,
     * 이 과정은 직관적이지 않고 버그를 유발하기 쉽다.
     *
     * 스트림스타일은 외부 반복을 하지 않고, 각 개별 엘리먼트에 대한 처리로직를 수행할수 있는 여러 함수들을 제공한다.
     * 그 함수들은 of,filter, reduce, map,  collect 등이다. 그리고 이 스트림 함수들은 행동패턴을 기술하는 람다식을 파러미터 값으로 받는다.
     * 아래와 같이 차이를 비교할수 있다.
     */

    /*
     * 컬렉션 스타일과 스트림 스타일의 비교
     */
    private void stream() {
        List<Trade> trades = new ArrayList<>();

        /*
         * AS-IS
         */
        for (Trade trade : trades) {
            if (trade.getQuantity() > 100000 &&
                    (trade.getIssuer().equals("GOOG")) &&
                    (trade.getStatus().equals("PEND"))) {
            }
        }

        /*
         * TO-BE
         */
        Stream<Trade> filteredTrades =
                trades.stream()
                        .filter(t -> t.getIssuer().equals("GOOG"))
                        .filter(t -> t.getQuantity() > 100000)
                        .filter(t -> t.getStatus().equals("PEND"));
    }

    private void streamFunc()
    {
        /*
         * Stream.of({param})
         *
         * 배열을 스트림객체로 변경해준다.
         */
        Integer[] ids1 = {1, 2, 3, 4};
        Stream intStream = Stream.of(ids1);

        /*
         * map()
         *
         * 하나의 파라미터 값을 인자로 받아서 다른 임의의 형태로 리턴한다.
         */
        Integer[] ids2 = {1, 2, 3, 4};
        Stream.of(ids2).map(x -> x * 10.0);

        /*
         * reduce()
         *
         * 두개의 파라미터 값을 받아 연산후 다른 형태로 리턴한다.
         * 여기서 앞의 값은 초기값이자 수식의 결과로 나온 리턴값을 의미한다.
         */
        Integer[] ids3 = {1, 2, 3, 4};
        int ret = Stream.of(ids3)
                .reduce(0, (a, b) -> {
                    System.out.println("lambda a=" + a + " b=" + b);
                    return a + b;
                });

        /*
         * collect()
         *
         * 스트림객체는 기본적으로 연속적인 성격을 갖는데, 이것은 filter, map,reduce등의 연산이후에도 여전이 최종 값이라고는 볼수 없다는 뜻이다.
         * filter,map,reduce는 지정된 하나의 데이터셋뿐 아니라, 계속적으로 이어지는 값들의 연속적인 흐름 즉 stream이라고 할수 있다.
         *
         * 이런 스트림형태의 흐름값으로부터 사용자가 직접 값을 이용할수 있는 형태를 가지려면 배열혹은 컬렉션의 형태를 통해 접근할수 있다.
         * 이렇게 stream의 filter,map,reduce후의 최종적인 값을 얻으려면 collect라는 함수를 호출한다.
         *
         * 이러한 최종값을 얻는 형태를 terminal이라고 하는데, collect가 불리기전의 map,filter,reduce등은 실제로 실행되지 않고,
         * collect혹은 foreach등의 terminal operation전까지는 수행이 지연된다.
         *
         * collect의 인자는 List로 받고 싶을 경우 Collectors.toList(), 특적한 콜렉션 구현체로 받고 싶을 경우에는
         * Collectiors.toCollection(ArrayList::new);의 형태를 취한다. ArrayList::new가 약간 이상해 보일수도 있을 것이다.
         *
         * 이것은 자바 8에 추가된 메소드 참조 기능이다.
         * 클래스의 메소드를 직접 참조할수 있으며, 파라미터로는 toCollection로 만들어진 컬렉션 객체가 들어가서 최종적으로 ArrayList객체가 생성된다.
         */
        List<Double> list1 = Stream.of(ids1).map(x -> x * 10.0).collect(Collectors.toList());
        ArrayList<Double> arrayList = Stream.of(ids1).map(x -> x * 10.0).collect(Collectors.toCollection(ArrayList::new));

        /*
         * parallel()
         *
         * 스트림객체의 커다란 장점은 병렬 프로세싱이 용이하다는 점이다.
         * 스트림객체는 parallel()메소드를 통해 병렬처리를 지원하는 parallel객체로 변형될수 있고, 한번 변형이 된 병렬 스트림 객체는 멀티코어 환경에서 동작하게 된다.
         * 여기서 생성된 병렬 스트림객체는 그이후에 filter,map,reduce,collect 그 어느 행위를 하건 동시성 이슈, race condition, shared memory problem이 없이 안전하게 수행된다.
         * 이것은 함수형 프로그래밍의 inner iteration으로 인한 큰 장점이다.
         */
        List<Double> list2 = Stream.of(ids2).parallel().map(x -> x * 10.0).collect(Collectors.toList());
    }

    private void streamAndForeach()
    {
        /*
         * 스트림객체과 람다식을 사용해 다양한 스트림을 활용한 처리를 해보았다.
         * 분명 스트림방식은 쿼리방식을 사용해 데이터를 직관적이고도 명확하게 다루는 방법을 제공해준다.
         * 그러나 스트림 객체는 단점또한 존재한다.
         *
         * 장점)
         *     직관적인 프로그래밍을 도와준다.
         *     코딩라인을 많이 줄여준다.
         *     Inner Iteration으로 변이성을 줄여 실수를 방지한다.
         *     병렬 프로그래밍에 용이히다.
         *
         * 단점)
         *     일반적으로 Stream의 forEach는 동일한 로직의 For Loop보다 10~20% 느리다.
         *     특히 Primitive형태의 Array들(int, double등)은 Stream이 아직 훨씬느리다. (JDK8기준.. 나중에 개선될수 있다.)
         *     Exception이 발생할때 Callstack이 훨씬 많이 찍혀서 디버깅이 어렵다.
         *     때로 읽기가 더욱 어려워진다.
         *
         *  결론적으로 항상 Stream을 사용한 함수형 프로그래밍이 좋다고 할수는 없다.
         *  자바기본의 명령형 프로그래밍의 스타일이 좋은 경우도 다양하게 존재하기 떄문에 그때 그때 요구사항에 걸맞는 솔루션을 선택 할수 있는 현명함이 필요하다.
         */
    }

</xmp>
    </div>
  </section>
</body>
</html>