코루틴 스터디

---



### [4장 일시 중단 함수와 코루틴 컨텍스트](http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&ejkGb=KOR&barcode=9791161754222)

- 일시 중단 함수의 개요
- 일시 중단 함수를 사용하는 방법
- 일시 중단 함수 대신 비동기 함수를 사용하는 경우
- 코루틴 컨텍스트
- 디스패처, 예외 처리기 및 취소 불가와 같은 다양한 유형의 컨텍스트
- 코루틴 동작을 정의하기 위한 컨텍스트의 결합 및 분리

위 내용을 주제로 정리되어 있습니다.



#### **일시 중단 함수**

launch(), async(), runBlocking() 과 같은 코루틴 빌더를 사용해서 일시 중단 알고리즘의 대부분을 작성합니다.

**코루틴 빌더를 호출 할 때 전달하는 코드는 일시 중단 함수 (suspend)** 이며 코드 작성법은 아래와 같다.



ex/

```kotlin
suspend fun greeetDelayes(delayMillis: Long) {
  delay(delayMillis)
  println("Hello, world!")
}
```



**일시 중단 함수를 만들려면 시그니처에 suspend 제어자만을 추가** 하면 됩니다.

일시 중단 함수는 **delay() 와 같은 다른 일시 중단 함수를 직접 호출이 가능**합니다.

(비 일시 중단 코드에서 함수를 호출하려면 아래와 같이 코루틴 빌더로 감싸주어야 합니다)



ex/

```kotlin
fun main(args: Array<String>) {
  runBlocking {
    greetDelayed(1000)
  }
}
```



#### 동작 중인 함수를 일시 중단

일시 중단 함수를 활용하여 (저자 입장에서 더 편리하다고 말하는) 비동기 함수를 확장해보고 사례를 통해 비교해보고자 합니다.



> 우리는 비동기 함수를 구현한 잡(Job) 을 (디퍼드(Deferred) 를 토함해서) 반환하는 함수라고 했다. 이러한 함수는 보통은 launch() 또는 async() 빌더로 감싸인 함수이지만, 구현한 잡이 반환될 때만 비동기 함수로 본다.



**비동기 함수로 레파지토리 작성**

잡 구현을 반환하는 함수가 있다면 편리할 수 있지만, **코루틴이 실행되는 동안에 일시 중단을 위해서 join() 이나 await() 를 사용하는 코드가 필요하다는 단점**이 생깁니다. **기본 동작으로 일시 중지를 하고 싶으면 아래와 같이 작성**하면 됩니다.



ex/

```kotlin
interface ProfileServiceRepository {
  fun asyncFetchByName(name: String): Deferred<Profile>
  fun asyncFetchById(id: Long): Deferred<Profile>
}

class ProfileServiceClient: ProfileServiceRepository {
  override fun asyncFetchByName(name: String): GlobalScope.async {
    Profile(someValue)
  }
  
  override fun asyncFetchById(id: Long): GlobalScope.async {
    Profile(someValue)
  }
}

fun main(args: Array<String>) = runBlocking {
  val client: ProfileServiceRepository = ProfileServiceClient()
  val profile = client.asyncFetchById(1).await()
  // @description 요청이 완료될 때까지 일시 정지해야하므로 함수 호출 직후에 await() 호출이 있게 됩니다.
}
```



@todo. RxJava 로 위 케이스 구현 예시



**일시 중단 함수로 업그레이드 **(리팩토링)



ex/

```kotlin
interface ProfileServiceRepository {
  suspend fun fetchByName(name: String): Profile
  suspend fun fetchById(id: Long): Profile
}

class ProfileServiceClient: ProfileServiceRepository {
  override suspend fun fetchByName(name: String): Profile {
    return Profile(someValue)
  }
  
  override suspend fun fetchById(id: Long): Profile {
    return Profile(someValue)    
  }
}

fun main(args: Array<String>) = runBlocking {
  val client: ProfileServiceRepository = ProfileServiceClient()
  val profile = client.fetchById(1)
}
```



비동기 구현에 비해 분명한 이점이 있습니다.

1. **유연함**: 인터페이스의 상세 구현 내용은 노출되지 않기 때문에 **퓨처를 지원하는 모든 라이브러리를 구현에서 사용할 수 있습니다.**
2. **간단함**: 순차적으로 수행하려는 작업에 비동기 함수를 사용하면 **항상 await() 를 호출해야 하는 번거로움이 없어집니다.**



@todo. Java Future, Spring Reactor 결합 예시



갓스펜드...



**일시 중단 함수와 비동기 함수**

비동기 함수 대신 일시 중단 함수를 사용하기 위함 가이드라인은 다음과 같습니다.



- 일반적으로 구현에 Job 이 엮이는 것을 피하기 위해서는 **일시 중단 함수를 사용하는 것이 좋습니다.**
- **인터페이스를 정의할 때는 항상 일시 중단 함수를 사용**한다. 비동기 함수를 사용하면 Job 을 반환하기 위한 구현을 해야 합니다.
- **마찬가지로 추상 함수를 정의할 때는 항상 일시 중단 함수를 사용**합니다. **가시성이 높은 함수일수록 일시 중단 함수를 사용**해야 합니다. 



@todo. 일시 중단 함수 예시 / 성능 비교

@todo. suspend 내부 



#### 코루틴 컨텍스트

코루틴은 항상 컨텍스트 안에서 실행됩니다. 컨텍스트는 코루틴이 어떻게 실행되고 동작해야 하는지를 정의할 수 있게 해주는 요소들의 그룹입니다.



> 컨텍스트는 실제로 둘 이상의 요소를 포함할 수 있습니다. 이번 장에서는 결합된 동작을 생성하기 위해 컨텍스트에서 요소를 추가하고 제거하는 방법을 설명합니다.



**디스패쳐**

코루틴이 실행될 스레드를 결정하는데 여기에는 시작될 곳과 중단 후 재개될 곳을 모두 포함합니다.



**CommonPool** (Default)

**CPU 바운드 작업을 위해서 프레임워크에 의해 자동으로 생성되는 스레드 풀**입니다.

스레드 풀의 최대 크기는 시스템의 코어 수에서 1을 뺀 값이며 현재는 **기본 디스패쳐로 사용**되지만 용도를 명시할 수도 있습니다.



ex/

```kotlin
GlobalScope.launch(Dispatchers.Default) {
  // TODO. 구현
}
```



> CommonPool 이 기본 디스패쳐로써 지원하는 것을 중단할지는 확실하지 않지만, 예상치 못한 변경에 대비하기 위해 CPU 바운드 작업에 명시적으로 사용하는 것을 고려합니다.



**Unconfined**

**첫번째 중단 지점에 도착할 때까지 현재 스레드에 있는 코루틴을 실행**합니다. 코루틴은 일시 중지된 후에 **일시 중단 연산에서 사용된 기존 스레드에서 다시 시작**됩니다.



@todo. 원리 ? 내부 로직 ?



> suspend a() 가 특정 스레드에 있는 디스패처와 함께 실행되는 suspend b() 를 호출할 경우, a() 는 b() 가 실행된 같은 스레드에서 다시 시작되며 이것은 일시 중단 연산을 컴파일 하는 방식 때문에 발생한다고 합니다.
>
> 9장에서 상세하게 설명한다고 합니다 (태화님 👏🏻)



ex/

```kotlin
fun main(args: Array<String>) = runBlocking {
  GlobalScope.launch(Dispatchers.Unconfined) {
    println("Starting in ${Thread.currentThread().name}")
    delay(500)
    println("Resuming in ${Thread.currentThread().name}")
  }.join()
}
```



... **시작은 main 스레드에서 실행** 중이였지만, 그 다음 **일시 중단 연산이 실행된 Default Executor 스레드로 이동**한 것을 보실 수 있습니다.



@todo. 다양한 테스트 (내부 컨텍스트가 많아져도 동일?)



**단일 스레드 컨텍스트**

**항상 코루틴이 특정 스레드 안에서 실행된다는 것을 보장**합니다. 유형의 디스패처를 생성하려면 newSingleThreadContext() 를 사용해야 합니다.



ex/

```kotlin
fun main(args: Array<String>) = runBlocking {
  val dispatcher = new SingleThreadContext("myThread")
  
  GlobalScope.launch(dispatcher) {
    println("Starting in ${Thread.currentThread().name}")
    delay(500)
    println("Resuming in ${Thread.currentThread().name}")
  }.join()
}
```



... **일시 중지 후에도 항상 같은 스레드에서 실행**됩니다.



**스레드 풀**

스레드 풀을 갖고 있으며 **해당 풀에서 가용한 스레드에서 코루틴을 시작하고 재개**합니다. **런타임이 가용한 스레드를 정하고 부하 분산을 위한 방법도 정하기 때문에 따로 할 작업은 없습니다.**



ex/

```kotlin
fun main(args: Array<String>) = runBlocking {
  val dispatcher = new SingleThreadContext(4, "myPool")
  
  GlobalScope.launch(dispatcher) {
    println("Starting in ${Thread.currentThread().name}")
    delay(500)
    println("Resuming in ${Thread.currentThread().name}")
  }.join()
}
```



... **myPool-1, myPool-2 등의 생성한 횟수만큼의 풀 (4) 을 가지고 코루틴을 시작**하게 됩니다.



@todo. 스레드 풀을 직접 설정해서 사용하는 케이스는 무엇?



**예외 처리**

코루틴 컨텍스트의 또 다른 중요한 용도는 **예측이 어려운 예외에 대한 동작을 정의**하는 것이며 이러한 유형은 **CoroutineExceptionHandler 를 구현**해 만들 수 있습니다.



ex/

```kotlin
fun main(args: Array<String>) = runBlocking {
  val handle = CoroutineExceptionHandler({ context, throwable ->
    println("Error captured in $context")
    println("Message: ${throwable.message}")
  })
  
  GlobalScope.launch(handler) {
    // TODO. 구현
  }
  
  // wait for the error to happen
  delay(500)
}
```



... 

@todo. 이게 왜 에러인지?



**Non-cancellable**

**코루틴의 실행이 취소되면 코루틴 내부에 CancellationException 유형의 예외가 발생하고 코루틴이 종료**됩니다. 코루틴 내부에서 예외가 발생하기 때문에 try-finally 블록을 사용해 리소스를 닫는 클리닝 작업을 수행하거나 로깅을 수행할 수 있습니다.



ex/

```kotlin
fun main(args: Array<String>) = runBlocking {
  val duration = measureTimeMillis {
    val job = launch {
      try {
        while(isActive) {
          delay(500)
          println("still running")
        }
      } finally {
        println("cancelled, will end now")
      }
    }
    
    delay(1200)
    job.cancelAndJoin()
  }
  
  println("Took $duration ms")
}
```



@todo. measureTimeMillis 이게 뭐지?



... **코루틴을 취소할 때는 finally 블록이 실행**됩니다. 메인 스레드가 1.2초 동안 일시 중지된 다음 작업을 취소하고 애플리케이션 종료 전에 전체 실행 시간을 출력합니다.



이번에는 **코루틴이 종료되기 전에 5초 동안 멈추도록 finally 블록을 수정**해봅니다.



ex/

```kotlin
fun main(args: Array<String>) = runBlocking {
  val duration = measureTimeMillis {
    val job = launch {
      try {
        while(isActive) {
          delay(500)
          println("still running")
        }
      } finally {
        println("cancelled, will delay finalization now")
        delay(5000)
        println("cancelled, will end now")
      }
    }
    
    delay(1200)
    job.cancelAndJoin()
  }
  
  println("Took $duration ms")
}
```



... 하지만 finally 블록에서의 실제 지연은 일어나지 않았습니다. 코루틴이 일시 중단된 후 바로 종료되었습니다. 그 이유는 **취소중인 코루틴은 일시 중단될 수 없도록 설계되었기 때문**입니다. **코루틴이 취소되는 동안 일시 중지가 필요한 경우에는 NonCancellable 컨텍스트를 사용**해야 합니다.



ex/

```kotlin
fun main(args: Array<String>) = runBlocking {
  val duration = measureTimeMillis {
    val job = launch {
      try {
        while(isActive) {
          delay(500)
          println("still running")
        }
      } finally {
        withContext(NonCancellable) {
          println("cancelled, will delay finalization now")
          delay(5000)
          println("cancelled, will end now")
        }
      }
    }
    
    delay(1200)
    job.cancelAndJoin()
  }
  
  println("Took $duration ms")
}
```



@todo. withContext(NonCancellable) 원리가 뭐지?



... 코루틴의 취소 여부와 관계없이 **withContext() 에 전달된 일시 중단 람다가 일시 중단될 수 있도록 보장**해줍니다.



#### 컨텍스트에 대한 추가 정보

컨텍스트는 코루틴이 어떻게 동작할지에 대한 다른 세부사항들을 많이 정의할 수 있습니다. 뿐만 아니라 결합된 동작을 정의해 작동하기도 합니다.



**컨텍스트 조합**

**특정 스레드에서 실행하는 코루틴을 실행하고 동시에 해당 스레드를 위한 예외처리를 설정한다고 가정**합니다. 이를 위해 **더하기 연산자를 사용해 둘을 결합**할 수 있습니다.



ex/

```kotlin
fun main(args: Array<String>) = runBlocking {
  val dispatcher = newSingleThreadContext("myDispatcher")
  val handler = CoroutineExceptionHandler({ _, throwable ->
    println("Error captured")
    println("Message: ${throwable.message}")                                       
  })
  
  // val context = dispatcher + handler
  // 또는 변수로 만들어 활용할 수 있습니다.

  GlobalScope.launch(dispatcher + handler) {
    println("Running in ${Thread.currentThread().name}")
  }.join()
}
```



**컨텍스트 분리**

**결합된 컨텍스트에서 컨텍스트 요소를 제거**할 수도 있습니다. 이렇게 하려면 제거할 요소의 키에 대한 참조가 있어야 합니다.



ex/

```kotlin
fun main(args: Array<String>) = runBlocking {
  val dispatcher = newSingleThreadContext("myDispatcher")
  val handler = CoroutineExceptionHandler({ _, throwable ->
    println("Error captured")
    println("Message: ${throwable.message}")                                       
  })
  
  val context = dispatcher + handler

  val tmpCtx = context.minusKey(dispatcher.key)
  // 컨텍스트에서 하나의 요소를 제거
  
  GlobalScope.launch(tmpCtx) {
    println("Running in ${Thread.currentThread().name}")
  }.join()
}
```



**withContext 를 사용하는 임시 컨텍스트 스위치**

**이미 일시 중단 함수 상태에 있을 때 withContext() 를 사용해 코드 블록에 대한 컨텍스트를 변경**할 수 있습니다. withContext() 는 코드 블록 실행을 위해 주어진 컨텍스트를 사용할 일시 중단 함수입니다.



ex/

```kotlin
fun main(args: Array<String>) = runBlocking {
  val dispatcher = newSingleThreadContext("myThread")
  val name = withContext(dispatcher) {
    // 중요한 작업 수행 및 이름 반환
    "Susan Calvin"
  }
  
  println("User: $name")
}
```



... **main 은 join() 이나 await() 을 호출할 필요 없이 이름을 가져올 때까지 일시 중단**됩니다.



4장의 내용을 정리하자면 아래와 같습니다.

- **일시 중단 함수의 개요 및 일시 중단 함수를 사용하는 방법**

  - 코루틴 빌더를 호출 할 때 전달하는 코드는 일시 중단 함수 (suspend) 입니다.

  - suspend 제어자만을 추가하면 되기 때문에 불필요한 코드 작성이 없어 간단 명료합니다.

    

- **일시 중단 함수 대신 비동기 함수를 사용하는 경우**

  - **유연함**: 인터페이스의 상세 구현 내용은 노출되지 않기 때문에 **퓨처를 지원하는 모든 라이브러리를 구현에서 사용할 수 있습니다.**

  - **간단함**: 순차적으로 수행하려는 작업에 비동기 함수를 사용하면 **항상 await() 를 호출해야 하는 번거로움이 없어집니다.**

    

- **코루틴 컨텍스트**

  - **CommonPool**: CPU 바운드 작업을 위해서 프레임워크에 의해 자동으로 생성되는 스레드 풀

  - **Unconfined**: 첫번째 중단 지점에 도착할 때까지 현재 스레드에 있는 코루틴을 실행합니다. 코루틴은 일시 중지된 후에 일시 중단 연산에서 사용된 기존 스레드에서 다시 시작되는 방식

    

- **디스패처, 예외 처리기 및 취소 불가와 같은 다양한 유형의 컨텍스트**

  - **단일 스레드 컨텍스트**: **항상 코루틴이 특정 스레드 안에서 실행된다는 것을 보장**합니다. 유형의 디스패처를 생성하려면 newSingleThreadContext() 를 사용하는 방식

  - **스레드 풀**: 스레드 풀을 갖고 있으며 해당 풀에서 가용한 스레드에서 코루틴을 시작하고 재개하는 방식

  - **예외 처리**: 코루틴 컨텍스트의 또 다른 중요한 용도는 **예측이 어려운 예외에 대한 동작을 정의**하는 것이며 이러한 유형은 **CoroutineExceptionHandler 를 구현**해 만들 수 있습니다.

    

- **코루틴 동작을 정의하기 위한 컨텍스트의 결합 및 분리**

  - **컨텍스트 조합**: **특정 스레드에서 실행하는 코루틴을 실행하고 동시에 해당 스레드를 위한 예외처리를 설정한다고 가정**합니다. 이를 위해 **더하기 연산자를 사용해 둘을 결합**할 수 있습니다.
  - **컨텍스트 분리: **결합된 컨텍스트에서 컨텍스트 요소를 제거**할 수도 있습니다. 이렇게 하려면 제거할 요소의 키에 대한 참조가 있어야 합니다.
  - **withContext 를 사용하는 임시 컨텍스트 스위치**: **이미 일시 중단 함수 상태에 있을 때 withContext() 를 사용해 코드 블록에 대한 컨텍스트를 변경**할 수 있습니다. withContext() 는 코드 블록 실행을 위해 주어진 컨텍스트를 사용할 일시 중단 함수입니다

